++++++++++++++++++++++++++++++++++
GraphQL and Python and my Opinions
++++++++++++++++++++++++++++++++++

GraphQL is three steps forward and two steps back.

What led to GraphQL?
====================

This is the story I heard.  I don't know how true it is.

The Facebook mobile app team complained that working with their REST API
had these problems:

*   Each screen required dozens of separate queries.

*   Each query is a network call that used up limited customer data.

*   Even if data is free, each query takes time!

*   Each response came back with way more data than they really needed.
    There was no built-in way to list the fields they needed.

This is what I imagine they dealt with
======================================

Pretend we have to make a news feed page.  We might do it like this:

A.  Get information about this user's friends (1 query).

B.  For each friend, get recent posts for that user.  That means you
    make N queries, where is the number of friends of this person.

    After each query, link the post with the friend's information, like
    their display name and profile picture, in the application code.

C.  Sort the posts by time (or whatever secret they use) in application
    code.

D.  Display the first X posts, and in each post, display a few fields.

They could just write an API for every screen!
==============================================

When you make a screen, you tell the API team what data you need, and
they make you an API for that screen, with exactly the data you need,
fetched as efficiently as possible.

Problems:

*   This is labor-intensive!

*   When screen A and screen B and screen C share 50% of the same needs,
    you either copy and paste code, or you don't fetch it efficiently,
    or you write a complex SQL query that triggers madness in all who
    try to read it.

*   What if screens are dynamic / determined at run time?  For example,
    imagine a web-based spreadsheet where people can punch buttons to
    show and hide columns.

They could just cache in the client!
====================================

The app could cache as much data as possible and it is really clever
about only pulling down updates.

The source control system git kind of works like this.  So does couch
DB.

Problems:

*   In my experience, bad caching is the single biggest source of bugs.

*   Wikipedia has 17 different cache replacement algorithms and all of
    them have one scenario where they don't work great.

GraphQL examples
================

You can do three things with GraphQL:

*   do a query (like a read or a select)
*   do a mutation (like insert or update or delete)
*   subscribe to a topic (get notifications from the server)

GraphQL query examples
======================



GraphQL is kind of like a SQL view
==================================

In SQL, you make a bunch of tables.  Then you write a select query that
lists what columns you want.

The Grog Shop is a small bar and music venue in Cleveland Heights.  They
keep a list of upcoming shows on their website.

TODO: show a picture of upcoming shows at The Grog Shop.

You can imagine that a database for the Grog Shop has these tables:

* musicians

  * musician_id
  * name
  * description
  * thumbnail_picture_url

* events
  * event_id
  * name
  * event_date
  * doors_open
  * ticket_price

* event_lineups
  * event_id
  * musician_id
  * lineup_order
  * headliner (true or false)

TODO: write a SQL file with the actual table definitions for these.
TODO: write some INSERT statements to put some real data in there.

You might run a query like this to show upcoming events in the next 30
days::

  select events.event_date, events.name, musicians.name

  join event_lineups
  on events.event_id = event_lineups.event_id

  join musicians
  on event_lineups.musician_id = musicians.musician_id

  -- only show future shows
  where events.event_date > current_timestamp

  -- only show the next 30 days worth of events
  and events.event_date < current_timestamp + interval 30 days

  order by events.event_date,
  event_lineups.headliner, -- put headliners first
  event_lineups.lineup_order

If you find yourself doing that same select a bunch of times, you might
create a view in your database, and just select from that view.

GraphQL is kind of like that view!

When you have that view, you query it, and you list out what rows and
what columns you want.

What I like
===========

*   You build up a graph of all your data, and you can cover a lot of
    your typical data-collection stuff that would normally be a crapload
    of boring work is now done!

*   If some of your data is expensive to get, in other words, really
    slow to retrieve, then you can write a resolver so that it only
    retrieves that data when explicitly asked for.


What I dislike
==============

*   Selectively Caching POSTs based on payloads is not easy

*   You need to log POST data if you want to analyze slow operations.
    Everything looks the same!

*   Using curl with GraphQL isn't fun!

*   Using POSTs for reads goes against tradition.


Warnings
========

*   You'll likely need to handle mutations one by one.

*   People love putting a single GraphQL server in front of multiple
    services.  So depending on what fields you ask for, your query could
    be doing completely different things!

*   Like many other abstractions, you often will need to know what is
    going on underneath:

    *   When you say "give me rows 21 through 30!" does the pagination
        do what you want it to do, or does it retrieve all 500 rows
        every time and then discard them all?

    *   When you say "give me the objects with IDs in {11, 14, 19}, you make
        one POST to the GraphQL server, but does that server make one
        request for each object or does it get them in a single query?

    *   In the musicians example, the GraphQL schema says I can ask
        for every musician's instagram profile picture.  Just asking for
        that might trigger a separate network call for every artist.

        Or it might not!

        You can't tell unless you read the resolvers.

*   When you write resolvers, you need to make sure that you think
    through who is asking for what data.

    In other words, GraphQL doesn't solve thorny authorization issues.

    For example, imagine that you make a GraphQL interface for a bank.
    You limit access to logged-in users.  But in your resolvers, you
    need to make sure that Matt is only accessing data that Matt is
    blessed to access.

    This problem has been around forever.

When I would use it
===================

It makes a ton of sense for Github to set up a GraphQL API.  Every
different client can request a subset of all the possible fields.

Github would have to make dozens and dozens of JSON APIs to accomodate
all the different subsets of data you can get back.

How to write a Python client for the github GraphQL API?
========================================================

How to write a python GraphQL server?
=====================================

Final Thoughts
==============

3 steps forward, two steps back.

GraphQL is a big step forward when it comes to writing APIs for reading
data.









.. vim: set syntax=rst:
